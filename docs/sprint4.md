# Project Backlog: Sprint 4 - Screenshot Capture Functionality

### Introduction

This document provides a detailed backlog for Sprint 4 of the Time
Tracker application. Following the successful implementation of the
system tray functionality and the validation of our activity hooking
mechanism, this sprint focuses on adding another critical data
collection feature: periodic screenshot capture. The goal is to develop
a reliable, timer-based process that captures the user\'s screen and
saves it locally as a compressed image **to a standard user data
location**. This ensures the application adheres to modern best
practices for data storage. This sprint will also include a formal
review of the proof-of-concept log file from Sprint 3 to close out that
validation phase.

### User Stories

- **User Story 4.1**: Visual Activity Recording

  - **Description**: As a manager, I want the time tracking application
    to periodically capture screenshots of the user\'s screen, so that
    we have a visual record that provides context to their logged time
    and activity metrics.

  - **Actions to Undertake**:

    1.  **Introduce QTimer**: In the TimeTrackerMainWindow.h file, add a
        private member variable QTimer \*m_screenshotTimer = nullptr;.
        Include the \<QTimer\> header.

    2.  **Create Capture Slot**: In TimeTrackerMainWindow.h, declare a
        new private slot: void captureScreenshot();.

    3.  **Initialize and Configure Timer**: In the
        TimeTrackerMainWindow.cpp constructor, instantiate the
        m_screenshotTimer. Connect its timeout() signal to the
        captureScreenshot() slot. Set the timer\'s interval (e.g.,
        setInterval(10 \* 60 \* 1000) for 10 minutes, but use a shorter
        duration like 10 seconds for development and testing). Start the
        timer with m_screenshotTimer-\>start().

    4.  **Implement Screenshot Logic**: In the body of the
        captureScreenshot() slot, implement the screen capture using the
        Windows GDI API:

        - Get the screen\'s geometry (width and height).

        - Get the device context (DC) for the entire screen desktop.

        - Create a memory DC (CreateCompatibleDC) and a compatible
          bitmap (CreateCompatibleBitmap) with the screen\'s dimensions.

        - Use BitBlt to copy the pixel data from the screen DC into the
          memory DC.

    5.  **Convert to QImage and Save to AppData**: Convert the resulting
        Windows HBITMAP into a QImage. Use
        QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation)
        to get the standard application data path (e.g.,
        C:/Users/\<User\>/AppData/Local/Time Tracker Organization/Time
        Tracker). Use QDir to create a screenshots subdirectory within
        this path. Save the QImage as a JPEG file into this directory.
        The filename must be unique; use a timestamp for this (e.g.,
        screenshot_YYYYMMDD_HHMMSS.jpg).

    6.  **Resource Cleanup**: Ensure all GDI handles (HBITMAP, HDC) are
        properly deleted and released after the image has been saved to
        prevent memory and resource leaks.

    7.  **Review Proof-of-Concept Log**: As a final task for this
        sprint, formally review the activity_log.txt file generated by
        the work in Sprint 3 with the team. This is to confirm that the
        hooking mechanism is stable and captures the required data
        before it is refactored in a future sprint.

  - **References between Files**:

    - app/TimeTrackerMainWindow.h and app/TimeTrackerMainWindow.cpp: The
      core logic for the timer and screenshot capture will be added
      here. These files will now also depend on the \<QTimer\>,
      \<QStandardPaths\>, and \<QDir\> Qt headers.

    - C:/Users/\<User\>/AppData/Local/Time Tracker Organization/Time
      Tracker/screenshots/: This directory will be created at runtime by
      the application to store the captured images.

  - **Acceptance Criteria**:

    1.  When the application runs, a screenshots directory is created
        inside the application\'s local AppData folder if it does not
        already exist.

    2.  At a regular, configurable interval, a new .jpg screenshot file
        is created and saved into the AppData screenshots directory.

    3.  Each screenshot filename is unique and contains a timestamp.

    4.  The captured image is a valid JPEG file representing a
        full-screen capture of the user\'s primary monitor at the moment
        of capture.

    5.  The screenshot capture process runs in the background and does
        not cause the main application UI to freeze or become
        unresponsive.

    6.  The activity_log.txt from Sprint 3 has been reviewed, and the
        development team signs off that the proof-of-concept was
        successful.

  - **Testing Plan**:

    - The primary testing methodology will be manual functional testing.
      The application will be run, and the user\'s AppData directory
      will be monitored to verify the creation and integrity of the
      screenshot files.

### List of Files being Created / Modified

- **File 1**: /app/TimeTrackerMainWindow.h (Modified)

  - **Purpose**: To add the necessary declarations for the screenshot
    timer and its handler slot.

  - **Contents**: The class definition will be updated to include a
    QTimer\* member variable and the declaration for the
    captureScreenshot() private slot.

  - **Relationships**: This header defines the main window\'s interface.

- **File 2**: /app/TimeTrackerMainWindow.cpp (Modified)

  - **Purpose**: To implement the timer-based screenshot capture logic,
    saving files to a standard user location.

  - **Contents**: The constructor will be updated to initialize,
    configure, and start the QTimer. A new function,
    captureScreenshot(), will be added, containing the Windows GDI API
    calls for screen capture and the Qt logic for finding the AppData
    path and saving the image to a file.

  - **Relationships**: This file contains the core implementation logic
    and will depend on new Qt modules like \<QTimer\>, \<QDir\>, and
    \<QStandardPaths\>.

- **Directory 3**: C:/Users/\<User\>/AppData/Local/Time Tracker
  Organization/Time Tracker/screenshots/ (Created at Runtime)

  - **Purpose**: To provide a clean, user-specific, and permissions-safe
    location for storing all captured screenshots.

  - **Contents**: A collection of .jpg image files generated by the
    application.

  - **Relationships**: This directory is the output target for the
    screenshot capture functionality.

### Test Cases

- **Test Case 4.1**: Verify Screenshot Creation in AppData

  - **Test Data**: A running instance of the application with the timer
    interval set to 10 seconds.

  - **Expected Result**: The screenshots directory is created inside
    C:/Users/\<CurrentUser\>/AppData/Local/Time Tracker
    Organization/Time Tracker/. After 30 seconds of runtime, there
    should be approximately three .jpg files in the directory.

  - **Testing Tool**: Manual execution, Windows File Explorer
    (navigating to %LOCALAPPDATA%).

- **Test Case 4.2**: Verify Screenshot Content and Integrity

  - **Test Data**: The .jpg files generated by the application. The user
    should change the visible content on their screen between captures
    (e.g., switch between a text editor and a web browser).

  - **Expected Result**: Each .jpg file can be opened by a standard
    image viewer. The content of each image accurately reflects the
    state of the user\'s desktop at the time of capture.

  - **Testing Tool**: Windows Photos, or any image viewing software.

- **Test Case 4.3**: Verify Application Performance

  - **Test Data**: A running instance of the application.

  - **Expected Result**: While the application is running and capturing
    screenshots, the main UI remains responsive. The overall system CPU
    and memory usage should not increase significantly, with only brief,
    small spikes during the actual capture/save process.

  - **Testing Tool**: Manual interaction with the UI, Windows Task
    Manager.

- **Test Case 4.4**: Verify Proof-of-Concept Log (Sign-off)

  - **Test Data**: The activity_log.txt file generated during Sprint 3
    testing.

  - **Expected Result**: The development team reviews the log file and
    confirms that the data captured (keyboard and mouse events) is
    sufficient and accurate for the project\'s needs. This action is
    marked as complete in the project tracking tool.

  - **Testing Tool**: A text editor and a team meeting/discussion.

### Assumptions and Dependencies

- **Assumptions**:

  - The application is running on a Windows system with standard GDI
    capabilities.

  - For multi-monitor setups, this initial implementation will capture
    the primary monitor only. Capturing all monitors is out of scope for
    this sprint.

  - The application runs with standard user privileges, which is
    sufficient to write to the user\'s own AppData folder.

- **Dependencies**:

  - The successful completion of Sprints 1, 2, and 3 is a prerequisite.

  - The project must be correctly linked against the necessary Windows
    libraries (gdi32.lib, user32.lib), which is standard for a Visual
    Studio C++ project.

### Non-Functional Requirements

- **Performance**: The screenshot capture and save operation should be
  efficient. The target is for the entire process to take less than 500
  milliseconds on a standard machine to minimize its performance impact.

- **Resource Management**: All Windows GDI handles (HDC, HBITMAP) and
  other resources must be meticulously released in all code paths
  (including error conditions) to prevent resource leaks that could
  destabilize the application or the OS over long runtimes.

- **Storage**: The images should be saved with a reasonable JPEG
  compression quality (e.g., 85-90%) to balance image clarity with file
  size, preventing excessive disk space consumption.

### Conclusion

Upon completion of Sprint 4, the desktop application will be capable of
collecting all three primary data types required by the project:
keyboard activity, mouse activity, and periodic screenshots, with data
being saved to a robust, user-specific location. This marks a major
milestone, completing the core data collection features of the client
application. The subsequent sprints can now focus on refining this data
and establishing the communication pipeline to the backend server.
